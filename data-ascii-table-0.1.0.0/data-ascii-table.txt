-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ASCII table
--   
--   ASCII table
@package data-ascii-table
@version 0.1.0.0


-- | Let's make a table!
--   
--   <pre>
--   &gt; let Just (<a>Object</a> o1) = <a>decode</a> "{\"foo\": \"bar\"}"
--   &gt; let Just (<a>Object</a> o2) = <a>decode</a> "{\"baz\": 5}"
--   &gt; let Just (<a>Object</a> o3) = <a>decode</a> "{\"oink\": true}"
--   
--   &gt; let slice1 = [[Just o1, Just o3], [Just o2, Nothing]]
--   &gt; let slice2 = [[Nothing, Just o1]]
--   
--   &gt; <a>pretty</a> (<a>makeTable</a> ["object 1", "object 2"] [slice1, slice2, slice1])
--   +-----------+------------+
--   | object 1  | object 2   |
--   |           |            |
--   | baz foo   | foo   oink |
--   +===========+============+
--   |     "bar" |       True |
--   | 5.0       |            |
--   +-----------+------------+
--   |           | "bar"      |
--   +-----------+------------+
--   |     "bar" |       True |
--   | 5.0       |            |
--   +-----------+------------+
--   </pre>
module Data.AsciiTable

-- | An opaque data type with a <a>Pretty</a> instance, for printing to a
--   console. Build a table with <a>makeTable</a>, and show it with the
--   pretty-printing functions re-exported from this module.
data Table

-- | A single horizontal row of a <a>Table</a>, containing a list of
--   <a>TableElem</a>s. Each element in the row is visually separated from
--   the next by a vertical line. Each row in the table must contain the
--   same number of elements (however, any number of them can be
--   <a>Nothing</a>).
type TableRow a = [Maybe a]

-- | A single horizontal slice of a <a>Table</a>, containing one or more
--   <a>TableRow</a>s. Each slice is visually separated from the next by a
--   horizontal line.
type TableSlice a = [TableRow a]

-- | The class of types that correspond to a single element of a
--   <a>Table</a>. An instance for an <tt>aeson</tt> <a>Object</a> is
--   provided by this library.
class TableElem a
tableElemCells :: TableElem a => a -> HashMap Text Text

-- | Make a <a>Table</a> from a list of headers and a list of
--   <a>TableSlice</a>s, each of which contains a list of <a>TableRow</a>s,
--   each of which contain a list of <a>TableElem</a>s. It is assumed that
--   all dimensions align properly (e.g. each row contains the same number
--   of elements, which is equal to the length of the list of headers).
--   
--   Each vertically aligned element need not contain the same set of keys;
--   for example, the table corresponding to
--   
--   <pre>
--   [ {"foo": "bar"}, {"baz": "qux"} ]
--   </pre>
--   
--   will simply look like
--   
--   <pre>
--   +-------------+
--   | foo   baz   |
--   +=============+
--   | "bar"       |
--   |       "qux" |
--   +-------------+
--   </pre>
--   
--   That is, each missing value is simply not displayed.
makeTable :: TableElem a => [Text] -> [TableSlice a] -> Table

-- | The abstract data type <tt>Doc</tt> represents pretty documents.
--   
--   <tt>Doc</tt> is an instance of the <a>Show</a> class. <tt>(show
--   doc)</tt> pretty prints document <tt>doc</tt> with a page width of 100
--   characters and a ribbon width of 40 characters.
--   
--   <pre>
--   show (text "hello" `above` text "world")
--   </pre>
--   
--   Which would return the string "hello\nworld", i.e.
--   
--   <pre>
--   hello
--   world
--   </pre>
data Doc e :: * -> *

-- | The action <tt>(putDoc doc)</tt> pretty prints document <tt>doc</tt>
--   to the standard output, with a page width of 100 characters and a
--   ribbon width of 40 characters.
--   
--   <pre>
--   main :: IO ()
--   main = do{ putDoc (text "hello" &lt;+&gt; text "world") }
--   </pre>
--   
--   Which would output
--   
--   <pre>
--   hello world
--   </pre>
putDoc :: Doc e -> IO ()

-- | <tt>(hPutDoc handle doc)</tt> pretty prints document <tt>doc</tt> to
--   the file handle <tt>handle</tt> with a page width of 100 characters
--   and a ribbon width of 40 characters.
--   
--   <pre>
--   main = do{ handle &lt;- openFile "MyFile" WriteMode
--            ; hPutDoc handle (vcat (map text
--                              ["vertical","text"]))
--            ; hClose handle
--            }
--   </pre>
hPutDoc :: Handle -> Doc e -> IO ()

-- | The member <tt>prettyList</tt> is only used to define the <tt>instance
--   Pretty a =&gt; Pretty [a]</tt>. In normal circumstances only the
--   <tt>pretty</tt> function is used.
class Pretty a
pretty :: Pretty a => a -> Doc e
prettyList :: Pretty a => [a] -> Doc e

-- | The data type <tt>SimpleDoc</tt> represents rendered documents and is
--   used by the display functions.
--   
--   The <tt>Int</tt> in <tt>SText</tt> contains the length of the string.
--   The <tt>Int</tt> in <tt>SLine</tt> contains the indentation for that
--   line. The library provides two default display functions
--   <a>displayS</a> and <a>displayIO</a>. You can provide your own display
--   function by writing a function from a <tt>SimpleDoc</tt> to your own
--   output format.
data SimpleDoc e :: * -> *
SFail :: SimpleDoc e
SEmpty :: SimpleDoc e
SChar :: UnpkChar -> SimpleDoc e -> SimpleDoc e
SText :: UnpkInt -> String -> SimpleDoc e -> SimpleDoc e
SLine :: UnpkInt -> SimpleDoc e -> SimpleDoc e
SEffect :: e -> SimpleDoc e -> SimpleDoc e

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc e -> SimpleDoc e

-- | <tt>(renderCompact x)</tt> renders document <tt>x</tt> without adding
--   any indentation. Since no 'pretty' printing is involved, this renderer
--   is very fast. The resulting output contains fewer characters than a
--   pretty printed version and can be used for output that is read by
--   other programs.
renderCompact :: Doc e -> SimpleDoc e

-- | A slightly smarter rendering algorithm with more lookahead. It
--   provides provide earlier breaking on deeply nested structures. For
--   example, consider this python-ish pseudocode:
--   <tt>fun(fun(fun(fun(fun([abcdefg, abcdefg])))))</tt> If we put a
--   softbreak (+ nesting 2) after each open parenthesis, and align the
--   elements of the list to match the opening brackets, this will render
--   with <tt>renderPretty</tt> and a page width of 20c as: <tt>
--   fun(fun(fun(fun(fun([ | abcdef, | abcdef, ] ))))) | </tt> Where the
--   20c. boundary has been marked with |. Because <tt>renderPretty</tt>
--   only uses one-line lookahead, it sees that the first line fits, and is
--   stuck putting the second and third lines after the 20c mark. In
--   contrast, <tt>renderSmart</tt> will continue to check the potential
--   document up to the end of the indentation level. Thus, it will format
--   the document as:
--   
--   <pre>
--   fun(                |
--     fun(              |
--       fun(            |
--         fun(          |
--           fun([       |
--                 abcdef,
--                 abcdef,
--               ]       |
--     )))))             |
--   </pre>
--   
--   Which fits within the 20c. mark. In addition, <tt>renderSmart</tt>
--   uses this lookahead to minimize the number of lines printed, leading
--   to more compact and visually appealing output. Consider this example
--   using the same syntax as above: <tt>aaaaaaaaaaa([abc, def, ghi])</tt>
--   When rendered with <tt>renderPretty</tt> and a page width of 20c, we
--   get: <tt> aaaaaaaaaaa([ abc , def , ghi ]) </tt> Whereas when rendered
--   with <tt>renderSmart</tt> and a page width of 20c, we get: <tt>
--   aaaaaaaaaaa( [abc, def, ghi]) </tt>
renderSmart :: Int -> Doc e -> SimpleDoc e

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
displayS :: SimpleDoc e -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc e -> IO ()
instance GHC.Show.Show Data.AsciiTable.Table
instance GHC.Classes.Eq Data.AsciiTable.Table
instance Text.PrettyPrint.Free.Internal.Pretty Data.AsciiTable.Table
instance Data.AsciiTable.TableElem (Data.HashMap.Base.HashMap Data.Text.Internal.Text Data.Aeson.Types.Internal.Value)
